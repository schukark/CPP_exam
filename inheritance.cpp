#include <iostream>

/*
Три ключевых приниыпа ООП:
1. Инкаспусляция - классыб спецификаторы доступа
2. Полимпорфизм
    2а. Статичесикй(compile-time) шаблоны, наследование
    2б. Динмаичесикй(run-time) абстрактные классы, виртуальные методы
3. Наследование

*/

struct granny {};
struct mommy: granny {};
struct son : mommy {};

/*
бабка -> мама -> сын

Если создать объект класса сын, то создадутся экземпляры и его предков
В памяти они скорее всего располагаются подряд, хотя на это расчитывать не стоит
___________________
|granny|mommy|son|
___________________
*/

struct base {
    int a, b;
    base (const int a, const int b): a(a), b(b) {}
};

struct derived : base {
    int c, d;
    derived(const int c, const int d): c(c), d(d), base(c, d) {}
    // это обязательно, конструктор родителя обязательно надо вызвать, так как у родителя он не дефолтный
};

//  При создании сына, констукторы будут вызываться от родителя к ребенку, а деструкторы наоборот

/*
Спецификаторы наследования
public, protected, private

при private-наследовании protected|public поля становятся private
protected - protected|public поля становятся protected, private не меняется
public все наследуется без изменения модификатора 
*/


/*
Ключевое слово final - не позволяет наследоваться от данного класса
Например, 
*/
struct Granny {};
struct Mommy final: Granny {};


/*
При множественном наследовании также надо вызвать все конструкторы родителей
*/


/*
        Shape
       /     \
rectangle   rhombus
      \      /
       square

Ромбовидное наследование

При этом могут возникнуть проблемы дублирования
Для этого можно использовать вирутальное наследование
Тогда все потомки будут ссылаться на одного вирутально-созданного предка
*/
struct a: virtual base {};


/*
Обрезвание наследников при передаче
*/

struct Father{
    void foo() const {std::cout << "Base" << std::endl;}
};

struct Son : Father {
    void foo() const {std::cout << "Base" << std::endl;}
};

void greet(const Father& obj) {
    obj.foo();
}

int main() {
    Son f;
    greet(f); // Output: Base
}

/*
virtual позволяет переопределять методы у потомков
У предка метод помечается как virtual, а у потомка для переопределения пишется override
final у виртуальных методов работает так же как и классов
*/

//! void foo() const override {}

/*
Класс называется абстрактным, если все его методы чисто виртуальные
У абстрактного класса обязан быть виртульный дефолтный деструктор, чтобы избежать утечек памяти
(2 раза вызывается деструктор)
*/